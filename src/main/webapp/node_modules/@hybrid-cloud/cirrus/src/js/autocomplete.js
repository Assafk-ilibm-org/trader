// autocomplete

(() => {
  // To be supported for autocomplete, a text input element with class
  // 'js-autocomplete' should be immediately followed (next element sibling)
  // by a list with class 'list-autocomplete' which will be shown/hidden by
  // having an 'is-visible' class added/removed as needed. Items in the list
  // are descendants of the list with class 'list-autocomplete__item' and
  // should raise click events when their text content is to become the new
  // text input value.

  const acitem = '.list-autocomplete__item',
        aclist = '.js-autocomplete + .list-autocomplete',
        acselected = '.list-autocomplete__item.is-visible.is-selected',
        acvisible = '.list-autocomplete__item.is-visible',
        forEach = Array.prototype.forEach,
        show = 'is-visible',
        select = 'is-selected';

  const init = () => {
    let selectItem = (list, newitem) => {
      if ((newitem === -1) || (newitem === +1)) {
        let items = list.querySelectorAll(acvisible),
          selected = list.querySelector(acselected),
          ix = Array.prototype.indexOf.call(items, selected) + newitem;

        // if there wasn't a selected item, select the first item
        // if 'ix' goes out of range, 'items[ix]' will be undefined (falsy)
        newitem = items[selected ? ix : 0];
      }
      if (newitem && !newitem.classList.contains(select)) {
        forEach.call(list.querySelectorAll(acitem),
                        item => item.classList.toggle(select, item == newitem));
        let scrolly = newitem.getBoundingClientRect().top - list.getBoundingClientRect().top;
        if (scrolly < 0) {
          cassie.scroll(list, list.scrollTop + scrolly);
        } else if (scrolly + newitem.offsetHeight > list.offsetHeight) {
          cassie.scroll(list, list.scrollTop + scrolly + newitem.offsetHeight - list.offsetHeight);
        }
      }
    };

    let applyItem = (item, input) => {
      let value = item && (item.textContent || item.innerText /* IE */);
      if (value) {
        input.value = value;
        input.blur();
      }
    };

    let filterList = (list, input) => {
      let matcher = new RegExp(input.value, 'i');
      forEach.call(list.querySelectorAll(acitem), item => {
        console.log("Hello there!!!");
        let value = item.textContent || item.target.innerText /*IE*/ || '';
        if (value.search(matcher) >= 0) {
          item.classList.add(show);
        } else {
          item.classList.remove(show, select);
        }
      });
    };

    forEach.call(document.querySelectorAll(aclist), list => {
      console.log("Hello there!!!");
      let input = list.previousElementSibling;
      input.addEventListener('focus', e => list.classList.add(show));
      input.addEventListener('blur', e => list.classList.remove(show));
      input.addEventListener('keydown', e =>
        ((e.keyCode == 38) && selectItem(list, -1)) ||
        ((e.keyCode == 40) && selectItem(list, +1)) ||
        ((e.keyCode == 13) && applyItem(list.querySelector(acselected), input)));
      input.addEventListener('input', e => filterList(list, input));
      filterList(list, input);

      forEach.call(list.querySelectorAll(acitem), item => {
        item.addEventListener('mousemove', e => selectItem(list, item));
        item.addEventListener('click', e => applyItem(item, input));
      });
    });
  };

  util.initOnReady(init);

})();
